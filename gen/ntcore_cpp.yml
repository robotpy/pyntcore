---

functions:
  GetDefaultInstance:
    ignore: true
  CreateInstance:
    ignore: true
  DestroyInstance:
    ignore: true
  GetInstanceFromHandle:
    ignore: true
  GetEntry:
    overloads:
      NT_Inst, std::string_view:
        ignore: true
      NT_Topic, NT_Type, std::string_view, std::span<const PubSubOption>:
        ignore: true
  GetEntryName:
    ignore: true
  GetEntryType:
    ignore: true
  GetEntryLastChange:
    ignore: true
  GetEntryValue:
    ignore: true
  SetDefaultEntryValue:
    ignore: true
  SetEntryValue:
    ignore: true
  SetEntryFlags:
    ignore: true
  GetEntryFlags:
    ignore: true
  ReadQueueValue:
    ignore: true
  GetTopics:
    overloads:
      NT_Inst, std::string_view, unsigned int:
        ignore: true
      NT_Inst, std::string_view, std::span<const std::string_view>:
        ignore: true
  GetTopicInfo:
    overloads:
      NT_Inst, std::string_view, unsigned int:
        ignore: true
      NT_Inst, std::string_view, std::span<const std::string_view>:
        ignore: true
      NT_Topic:
        ignore: true
  GetTopic:
    ignore: true
  GetTopicName:
    ignore: true
  GetTopicType:
    ignore: true
  GetTopicTypeString:
    ignore: true
  SetTopicPersistent:
    ignore: true
  GetTopicPersistent:
    ignore: true
  SetTopicRetained:
    ignore: true
  GetTopicRetained:
    ignore: true
  GetTopicExists:
    ignore: true
  GetTopicProperty:
    ignore: true
  SetTopicProperty:
    ignore: true
  DeleteTopicProperty:
    ignore: true
  GetTopicProperties:
    ignore: true
  SetTopicProperties:
    ignore: true
  Subscribe:
    ignore: true
  Unsubscribe:
    ignore: true
  Publish:
    ignore: true
  PublishEx:
    ignore: true
  Unpublish:
    ignore: true
  ReleaseEntry:
    ignore: true
  Release:
    ignore: true
  GetTopicFromHandle:
    ignore: true
  SubscribeMultiple:
    ignore: true
  UnsubscribeMultiple:
    ignore: true
  AddTopicListener:
    overloads:
      NT_Inst, std::span<const std::string_view>, unsigned int, std::function<void ( const TopicNotification & )>:
        ignore: true
      NT_Handle, unsigned int, std::function<void ( const TopicNotification & )>:
        ignore: true
  CreateTopicListenerPoller:
    ignore: true
  DestroyTopicListenerPoller:
    ignore: true
  ReadTopicListenerQueue:
    ignore: true
  AddPolledTopicListener:
    overloads:
      NT_TopicListenerPoller, std::span<const std::string_view>, unsigned int:
        ignore: true
      NT_TopicListenerPoller, NT_Handle, unsigned int:
        ignore: true
  RemoveTopicListener:
    ignore: true
  AddValueListener:
    ignore: true
  CreateValueListenerPoller:
    ignore: true
  DestroyValueListenerPoller:
    ignore: true
  ReadValueListenerQueue:
    ignore: true
  AddPolledValueListener:
    ignore: true
  RemoveValueListener:
    ignore: true
  AddConnectionListener:
    ignore: true
  CreateConnectionListenerPoller:
    ignore: true
  DestroyConnectionListenerPoller:
    ignore: true
  AddPolledConnectionListener:
    ignore: true
  ReadConnectionListenerQueue:
    ignore: true
  RemoveConnectionListener:
    ignore: true
  GetNetworkMode:
    ignore: true
  StartLocal:
    ignore: true
  StopLocal:
    ignore: true
  StartServer:
    ignore: true
  StopServer:
    ignore: true
  StartClient3:
    ignore: true
  StartClient4:
    ignore: true
  StopClient:
    ignore: true
  SetServer:
    overloads:
      NT_Inst, char*, unsigned int:
        ignore: true
      NT_Inst, std::span<const std::pair<std::string_view, unsigned int>>:
        ignore: true
  SetServerTeam:
    ignore: true
  StartDSClient:
    ignore: true
  StopDSClient:
    ignore: true
  FlushLocal:
    ignore: true
  Flush:
    ignore: true
  GetConnections:
    ignore: true
  IsConnected:
    ignore: true
  Now:
    internal: true
  SetNow:
    internal: true
  GetTypeFromString:
    ignore: true
  GetStringFromType:
    ignore: true
  StartEntryDataLog:
    ignore: true
  StopEntryDataLog:
    ignore: true
  StartConnectionDataLog:
    ignore: true
  StopConnectionDataLog:
    ignore: true
  AddLogger:
    ignore: true
  CreateLoggerPoller:
    internal: true
  DestroyLoggerPoller:
    internal: true
  AddPolledLogger:
    internal: true
  ReadLoggerQueue:
    internal: true
  RemoveLogger:
    internal: true
classes:
  TopicInfo:
    attributes:
      name:
      type_str:
      properties:
    methods:
      GetProperties:
      swap:
        ignore: true
  ConnectionInfo:
    attributes:
      remote_id:
      remote_ip:
    methods:
      swap:
        ignore: true
    inline_code: |
      .def_readwrite("remote_port", &ConnectionInfo::remote_port)
      .def_readwrite("last_update", &ConnectionInfo::last_update)
      .def_readwrite("protocol_version", &ConnectionInfo::protocol_version)
      .def("__repr__", [](const ConnectionInfo &self) -> py::str {
        return py::str("<ConnectionInfo id={} addr={}:{} last_update={} protocol={}>")
          .format(self.remote_id, self.remote_ip, self.remote_port, 
                  self.last_update, self.protocol_version);
      })
  TopicNotification:
    attributes:
      info:
    methods:
      TopicNotification:
        overloads:
          "":
            ignore: true
          NT_TopicListener, nt::TopicInfo, unsigned int:
            ignore: true
      swap:
        ignore: true
    inline_code: |
      .def("__repr__", [](const TopicNotification &self) {
        return py::str("<TopicNotification topic_name=\"{}\" topic_type={} flags={}>")
          .format(self.info.name, self.info.type_str, self.flags);
      })
  ValueNotification:
    attributes:
      value:
    methods:
      ValueNotification:
        overloads:
          "":
            ignore: true
          NT_ValueListener, NT_Topic, NT_Handle, Value, unsigned int:
            ignore: true
      swap:
        ignore: true
    inline_code: |
      .def_readwrite("flags", &ValueNotification::flags)
      .def("__repr__", [](const ValueNotification &self) {
        auto topicInfo = nt::GetTopicInfo(self.topic);
        return py::str("<ValueNotification topic_name=\"{}\" topic_type={} flags={} value={}>")
          .format(topicInfo.name, topicInfo.type_str, self.flags, py::repr(py::cast(self.value)));
      })
  ConnectionNotification:
    attributes:
      connected:
      conn:
    methods:
      ConnectionNotification:
        overloads:
          "":
            ignore: true
          NT_ConnectionListener, bool, nt::ConnectionInfo:
            ignore: true
      swap:
        ignore: true
    inline_code: |
      .def("__repr__", [](const ConnectionNotification &self) -> py::str {
        return py::str("<ConnectionNotification connected={} info={}>")
          .format(self.connected, py::cast(self.conn));
      })
  LogMessage:
    attributes:
      filename:
      message:
    methods:
      LogMessage:
        overloads:
          "":
            ignore: true
          NT_Logger, unsigned int, std::string_view, unsigned int, std::string_view:
            ignore: true
      swap:
        ignore: true
    inline_code: |
      .def_readwrite("level", &nt::LogMessage::level)
      .def_readwrite("filename", &nt::LogMessage::filename)
      .def_readwrite("line", &nt::LogMessage::line)
      .def_readwrite("message", &nt::LogMessage::message);
  PubSubOption:
    attributes:
      type:
      value:
    methods:
      PubSubOption:
      Periodic:
      SendAll:
      TopicsOnly:
      KeepDuplicates:
      PollStorage:
    inline_code: |
      .def("__repr__", [](const PubSubOption& self) -> py::str {
        const char * tname = "kNone";
        switch (self.type) {
        case NT_PUBSUB_PERIODIC:
          tname = "kPeriodic";
          break;
        case NT_PUBSUB_SENDALL:
          tname = "kSendAll";
          break;
        case NT_PUBSUB_TOPICSONLY:
          tname = "kTopicsOnly";
          break;
        case NT_PUBSUB_POLLSTORAGE:
          tname = "kPollStorage";
          break;
        case NT_PUBSUB_KEEPDUPLICATES:
          tname = "kKeepDuplicates";
          break;
        }
        return py::str("PubSubOption(type=PubSubOption.Type.{}, value={})")
          .format(tname, self.value);
      });

      py::enum_<NT_PubSubOptionType>(cls_PubSubOption, "Type")
        .value("kNone", (NT_PubSubOptionType)0)
        .value("kPeriodic", NT_PUBSUB_PERIODIC)
        .value("kSendAll", NT_PUBSUB_SENDALL)
        .value("kTopicsOnly", NT_PUBSUB_TOPICSONLY)
        .value("kPollStorage", NT_PUBSUB_POLLSTORAGE)
        .value("kKeepDuplicates", NT_PUBSUB_KEEPDUPLICATES)


